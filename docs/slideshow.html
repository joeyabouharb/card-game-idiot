<!DOCTYPE html>
<html>
<head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
        @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
        @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
        @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

        body {
            font-family: 'Droid Serif';
        }

        h1,
        h2,
        h3 {
            font-family: 'Yanone Kaffeesatz';
            font-weight: normal;
        }

        .remark-code,
        .remark-inline-code {
            font-family: 'Ubuntu Mono';
        }
    </style>

</head>

<body>
    <textarea id="source">

class: center, middle

# Idiot Card Game

---

# Table of Contents

1. Introduction
2. Game flow
3. Code snippets
4. Considerations/ limitations

---

# Introduction

My application is a card game called idiot (otherwise called S***head) ;)
- Game Rules:
    - first player with no cards to play wins!
    - decks are split as follows:
        - Visible - cards that are face up on the table - playable once current hand is depleted
        - Hidden - cards that are face down on the table - playable once visible cards are played - played randomly one at a time.
        - Current Hand - Cards in players hand
- Features:
    - AI
    - User scores
    - Game rules implementation, randomisation elements (Deck, AI)
- Wildcards:
    - 7 reverses
    - 2 resets the deck values
    - a ten or 4 of a kind bombs the discard
---

# Game Flow
<img style="max-width: 800px" src="./game_flow.png"/>

---

# Snippets
### Main game loop

    while not check_if_game_ended(user_deck, opponent_deck):
        
        (deck, opponent_stats, is_human)\
            = get_next_turn(is_human, user_deck, opponent_deck)

        (played_card, is_wildcard)\
            = player_turn(is_human, discard, deck, opponent_stats)

        (played_card)\
            = on_card_played(deck, played_card, deck_generator, discard)

        (is_bomb, is_wildcard)\
            = check_if_bomb(discard, played_card, is_wildcard)

        while is_wildcard and\
        not check_if_game_ended(user_deck, opponent_deck):
            # handle wildcard turns...

    handle_end_game(user_deck, opponent_deck, is_human, name)

---
### wildcard handling

    def prompt wildcard turn(is_human: bool, discard: list,\
    deck: dict, opponent_stats: dict, played_card: dict):

        available_deck = get_available_play(deck)
        prompt = prompt_user_turn if is_human else prompt_opponent_turn

        if played_card['value'] == 2:
            (card, is_wildcard)\
                = two_is_played(prompt, available_deck, deck, discard, opponent_stats)

        elif played_card['value'] == 7:
            (card, is_wildcard)\
                = seven_is_played(prompt, available_deck, deck, discard, opponent_stats)

        else: # bomb happens here
            (card, is_wildcard)\
                = ten_is_played(prompt, available_deck, deck, discard, opponent_stats)

        return card, is_wildcard

---
### input validations

    `def validate_user_input(available_deck: str, user_input: str, user_deck: list,`
    `prev_card: dict)-> (int):`
        `user_input = user_input.strip()`
        `if not user_input.isdigit():`
        &emsp; `return None`
        `try:`
        &emsp; `val = int(user_input) - 1`
        `except ValueError:`
        &emsp; `return None`
        `if val >= len(user_deck):`
        &emsp; `return None`
        `if not check_card_values(available_deck, user_deck, prev_card, val):`
        &emsp; `return None`
    `return val`

---
### User Prompt
    def prompt_user_turn(available_deck: str, user_deck: dict,\
        prev_card: dict, oppenent_stats: dict, wildcard=False) -(object):
        sort_deck(available_deck, user_deck)

        deck = stringify_deck(user_deck, available_deck)
        wildcard_played = (
            ""
            if not wildcard
            else
            f'{wildcard["name"]} - Wildcard Played!\n'
        )
        previous = (
            "\nNo cards in discard\n"
            if not prev_card
            else
            f'\nBeat Previous Card {prev_card["name"]}\n'
        )
        stats = display_opponent_stats(oppenent_stats)
        view = (
            f'{stats}\n'
            f'{wildcard_played}\n'
            f'{previous}\n' + f'{deck}\n'
        )
        send_msg_to_user(view, False)
        play = handle_user_play(available_deck, user_deck, prev_card)
        if available_deck == 'hidden':
            send_msg_to_user(f'played: {play["name"]}')
        clear_output()
        return play


___
### User prompt
#### Handle user choice    
    def handle_user_play(available_deck: str, user_deck: dict,\
    prev_card: dict) -(object):

    user_hand = user_deck[available_deck]
    play = {}
    while not play:
        user_input = input('\033[1A\033[KSelect available options: ')
        split_input = user_input.split(' ')
        is_multiple = len(split_input) 1
        if not is_multiple:
            index = validate_user_input(available_deck, user_input, user_hand, prev_card)
            if index is not None:
                play = get_played_card(user_hand, index)
        else:
            indexes = validate_multi_input(available_deck, split_input, user_hand, prev_card)
            play = []
            if indexes:
                for number in indexes:
                    play.append(get_played_card(user_hand, number))
    return play


---
### AI

    def prompt_opponent_turn(available_deck: str, opponent_deck: dict,\
    prev_card: dict, opponent_stats: dict, wildcard=False) -(dict):

        if wildcard:
            send_msg_to_user(f'wildcard played! {wildcard["name"]}')
        enemy_is_winning = bool(not opponent_stats['cards_in_hand'])
        random_number = generate_random_number(1, 10)
        playable_deck = opponent_deck[available_deck]
        sorted_deck = sorted(playable_deck, key=itemgetter('value'))
        is_valid = False

    while not is_valid:
        index = select_choice_from_random(available_deck, random_number,\
            sorted_deck, prev_card, enemy_is_winning)
        is_valid = check_card_values(available_deck, sorted_deck, prev_card, index)
    duplicate = []
    wildcards = [2, 7, 10]
    if available_deck != 'hidden' and\
    sorted_deck[index]["value"] not in wildcards:
        duplicate = get_playable_cards(sorted_deck, index)
    selected_card = get_played_card(sorted_deck, index)

---

### AI

##### Rule handling...

    def select_an_ok_choice(available_deck: str, sorted_deck: list,\
    prev_card: dict, enemy_is_winning: bool) -(int):
        selected_index = None
        if enemy_is_winning and available_deck != 'hidden': # play high if enemy is winning
            sorted_deck.reverse()
            if not prev_card or sorted_deck[0]['value'] >= prev_card['value']:
            selected_index = 0
        elif available_deck != 'hidden': # play safe, play lowest possible card
            wildcards = [2, 7, 10]
            for i, card in enumerate(sorted_deck):
            if not prev_card or card['value'] >= prev_card['value'] and\
            card['value'] not in wildcards:
                selected_index = i
                break
        else: # if hidden
            selected_index = select_randomly(sorted_deck)
        if selected_index is None: # else play other wildcards if no higher card is found
            # ... more code here
---
# Considerations

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
        var slideshow = remark.create();
    </script>
</body>

</html>